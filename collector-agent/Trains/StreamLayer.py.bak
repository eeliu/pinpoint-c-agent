#!/usr/bin/env python
# -*- coding: UTF-8 -*-

from __future__ import print_function

import errno

from gevent import socket as asy_socket
from gevent import spawn
from gevent.event import Event  ## write signal
from gevent.queue import Queue  ## write buf

from Common import *
from TrainsLayer import *


class StreamLayer(TrainLayer):
    def __init__(self,remote,recv_msg_cb,hello_cb,auto_recover=True,timeout= 2):
        '''

        :param list remote:
        :param  recv_msg_cb:
        :param hello_cb:
        :param auto_recover:
        :param timeout:
        '''
        super(StreamLayer,self).__init__(remote,recv_msg_cb,auto_recover,timeout)
        self.RECV_BUF_SIZE = 4096
        self.recvBuf = bytearray(self.RECV_BUF_SIZE)
        self.pRBufStart = memoryview(self.recvBuf)
        self.hello_cb = hello_cb
        self.rest_data_sz = 0
        self.peer     = ()
        self.evt = Event()
        self.sendQueue = Queue()

    def close(self):
        TCLogger.warning("close connection with:(%s)", str(self.remote))
        self.socket.close()
        self.state = E_CLOSED
        self.evt.set()

    def _connectPeerWithTimeout(self, addr, time):
        self.socket = asy_socket.socket(asy_socket.AF_INET, asy_socket.SOCK_STREAM)
        self.socket.settimeout(time)

        try:
            self.socket.connect(addr)
            self.state = E_CONNECTED
            self.peer  = addr
            self.__rawFd = self.socket.fileno()
            TCLogger.info("connect peer: [%s:%d]" % (addr[0],addr[1]))
            return True
        except asy_socket.timeout as t:
            TCLogger.warning("connect:%s timeout:%d" % (addr, time))
        except Exception as e:
            TCLogger.warning("connect:%s error:%s" % (addr, str(e)))

        self.close()

        return False

    def _connectPeerWithHello(self, remote):
        self._connectPeerWithTimeout(remote, self.timeout)
        if self.state != E_CONNECTED:
            raise Exception("connection failed:%s"%str(remote))

        #  send hello to server
        if self.hello_cb is not None:
            self.hello_cb(self)

    def setSocketTimeout(self, time):
        self.socket.settimeout(time)

    def _recvFromPeer(self):
        recv_buf  = self.pRBufStart[self.rest_data_sz:]
        recv_total = self.rest_data_sz
        assert recv_total < self.RECV_BUF_SIZE
        try:
             recv_total = self.socket.recv_into(recv_buf,self.RECV_BUF_SIZE - recv_total)
             if recv_total == 0:
                 TCLogger.warning("peer: [%s:%d] closed",self.peer[0],self.peer[1])
                 self.close()
                 return -1
        except asy_socket.timeout as t:
            TCLogger.debug("read timeout")
            return 0
        except asy_socket.error as error:
            if error.errno in [errno.EAGAIN ]:
                return 0
            TCLogger.warning("peer error:%s ",error)
            self.close()
            return -1
        return recv_total

    def __sender(self):
        while self.state != E_CLOSED:
            self.evt.wait()
            while not self.sendQueue.empty():
                data = self.sendQueue.get()
                TCLogger.debug("snd len %d",len(data))
                self.socket.send(data)
            self.evt.clear()

    def _start_recv(self):
        while self.state != E_CLOSED:
            rLen = self._recvFromPeer()
            if rLen > 0:
                self.rest_data_sz = self.in_msg_cb(self, self.pRBufStart, rLen)
                if self.rest_data_sz > 0:
                    self.pRBufStart[0:self.rest_data_sz] = self.pRBufStart[rLen - self.rest_data_sz:rLen]
            elif rLen < 0:
                ## errno found
                return


    def start(self):

        self._connectPeerWithHello(self.remote)

        self.sender =      spawn(self.__sender)

        self.recver =      spawn(self._start_recv)



    def sendData(self,data):
        self.sendQueue.put(data)
        self.evt.set()

    def registerTimers(self,callback,time,args):
        loop = get_hub().loop
        time = loop.timer(0, time)
        time.start(callback,args)

    def getRawSocketFd(self):
        return self.__rawFd


def _test_hello_cb(n_layer):
    TCLogger.debug("send hello")
    n_layer.sendData("GET index.html \r\n\r\n")

def _test_in_msg_cb(self,barray, size):
    '''

    :param memoryview barray:
    :param size:
    :return:
    '''
    print( barray.tobytes())
    return 1

if __name__ == '__main__':
    tcpLayer = StreamLayer(("www.google.com",80), _test_in_msg_cb, _test_hello_cb)

    tcpLayer.start()
